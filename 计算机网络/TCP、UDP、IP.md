# TCP、UDP、IP

在 [网络分层](/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82.md) 中，传输层有两个人尽皆知的协议--TCP 与 UDP。

TCP 协议（Transmission Control Protocol，传输控制协议）为应用层提供可靠的、面向连接的和基于流（stream）的服务。TCP 协议使用超时重传、数据确认等方式确保数据包被正确地发送至目的端，因此 TCP 服务是可靠的。使用 TCP 协议通信的双方必须先建立 TCP 连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。当通信结束时，双方必须关闭连接以释放这些内核数据。TCP 服务是基于流的。**基于流的数据没有边界（长度）限制，它源源不断地从通信的一段流入另一端。** 发送端可以逐个字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。

UDP 协议（User Datagram Protocol，用户数据报协议）则与 TCP 协议完全相反，它为应用层提供不可靠、无连接的和基于数据报的服务。“不可靠”意味着 UDP 协议无法保证数据从发送端正确地传送到目的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则 UDP 协议只是简单地通知应用程序发送失败。因此，使用 UDP 协议地应用程序通常要自己处理数据确认、超时重传等逻辑。UDP 协议是无连接地，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP 地址等信息）。**基于数据报的服务，是相对基于流服务而言的。每个 UDP 数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。**

## TCP

TCP 是 TCP/IP 协议族中的一个重要协议，可以从

- TCP 头部信息：TCP 头部信息出现在每个 TCP 报文段中，用于指定通信的源端端口号、目的端口号、管理 TCP 连接，控制两个方向的数据流。
- TCP 状态转移过程。TCP 连接的任意一端都是一个状态机。在 TCP 连接从建立到断开的整个过程中，连接两端的状态机将经历不同的状态变迁。
- TCP 数据流：通过分析 TCP 数据流，可以从网络应用程序外部来了解应用层协议和通信双方交换的应用程序数据。
- TCP 数据流的控制：为了保证可靠传输和提高网络通信的质量，内核需要对 TCP 数据流进行控制。

四个方面去了解 TCP。

### TCP 头部信息

详见 [Socket 通信原理](/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.md) 中的 **TCP 报文段首部章节。**

### TCP 状态转移过程

详见 [Socket 通信原理](/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.md) 中的**TCP 的状态机、TCP 的三次握手和四次挥手 章节。**

### TCP 数据流

基于流的数据没有边界（长度）限制，它源源不断地从通信的一段流入另一端。发送端可以逐个字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。

TCP 字节流与 UDP 数据报的区别，如果对应到实际编程中，则体现为通信双方是否必须执行相同次数的读、写操作。当发送端应用连续多次执行多次写操作时，TCP 模块先将这些数据放入到 TCP 发送缓冲区中。当 TCP 模块真正开始发送数据时，发送缓冲区中等待发送的数据可能被封装成一个或多个 TCP 报文段发出。因此，TCP 模块发出的 TCP 报文段个数和应用程序执行写操作次数之间没有固定数量关系。

同样的，当接收端收到一个或多个 TCP 报文段后，将按照 TCP 报文段的序号依次放入到 TCP 接收缓冲区中，并通知应用程序读取数据。接收端应用程序可以一次性将 TCP 接收缓冲区的数据全部取出，也可以分多次读取，这取决于用户指定的应用程寻读缓冲区的大小。因此，TCP 模块接收到的 TCP 报文段个数和应用程序执行的读操作次数也没有固定的数量关系。

这就是字节流：应用程序对数据的发送和接收是没有边界的。

![tcp 字节流服务](/计算机网络/img/tcp字节流服务.png)

与之不同的是 UDP，一种基于数据报的协议。发送端应用程序每执行一次写操作，UDP 模块就将其封装称一个 UDP 数据报并发送之。接收端必须及时针对每一个 UDP 数据执行读操作，否则就会丢包。并且，如果用户没有指定足够的应用程序缓冲区来读取 UDP 数据，则 UDP 数据将被截断。

![udp 数据报服务](/计算机网络/img/udp数据报服务.png)

### TCP 数据流的控制

TCP 的三大特性--可靠、面向连接、基于流。其可靠性的保证，除了建立稳定的连接，在数据的收发处理上，也有一些措施去保证。

- 合理的数据大小：TCP 发送的数据并不是固定的大小，而是会根据实际情况调整报文段的大小。
- 检验和：发送端按照特定算法（CRC，参考 TCP 头部信息）计算出 TCP 报文段的检验和并存储在 TCP 首部中的对应字段上，接收端在接收时会以同样的方式计算校验和，如果不一致，说明报文段出现错误，会将其丢弃。
- 序号与确认序号：对乱序的数据进行排序后发给应用层，并丢弃重复的数据。
- 超时重传机制：当 TCP 发出一个报文段后，它会启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段，后面会细讲这个机制。
- 连接管理：也就是三次握手和四次挥手，连接的可靠性是整体可靠性的前提。
- 流量控制：TCP 双方都有固定大小的缓冲区，流量控制的原理是利用滑动窗口控制数据发送速度，避免缓冲区溢出导致数据丢失。
- 拥塞控制：TCP 利用慢启动和拥塞避免等算法实现了拥塞控制。

#### TCP 重传机制

TCP 要保证所有的包都可以到达，必须要有确认重传机制。

接收端给发送端的 Ack 确认只会确认最后一个连续的包，比如，发送端发了 1，2，3，4，5 一共 5 份数据，接收端收到了 1，2，于是回 ack 3，然后收到了 4（此时 3 没收到），此时 TCP 会怎么办？因为 SeqNum 和 Ack 是以字节数为单位，所以 ack 的时候，不能跳着确认，只能确认最大的连续收到的包。

**超时重传机制**

一种是不会 ack，死等 3，当发送方发现收不到 3 地 ack 超时后，会重传 3. 一旦接收方收到 3 后，会 ack 回 4--代表 3 和 4 都收到了。

但是，这种方法有着比较严重地问题，那就是因为要死等 3，所以会导致 4 和 5 即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到 ack，所以发送方可能会悲观地认为也丢了，所以有可能导致 4 和 5 的重传。

对此有两种选择：一种是仅重传 timeout 的包。也就是第三份数据。
另一种是重传 timeout 后所有的数据，也就是第 3，4，5 这三份数据。

这两种方法总体来说都不好。因为都在等 timeout，timeout 可能会很长。

>TCP 服务必须能够重传超时时间内未收到确认的 TCP 报文段。为此，TCP 模块为每个 TCP 报文段都维护一个重传定时器，该定时器在 TCP 报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP 模块将重传 TCP 报文段并重置定时器。

**快速重传机制（快重传 Fast Retransmit）**

另一种做法是，**不以时间驱动，而已数据驱动重传。**快重传算法要求接收方每收到一个失序的报文段后就立即发出重复确认（使发送方及早知道有报文段没有到达对方）而不要等待自己发送数据时才进行捎带确认。

快重传示意图如下：

![快重传示意图](/计算机网络/img/快重传示意图.webp)

接收方收到了 M1 和 M2 后都分别发出了确认。假如接收方没有收到 M3 但接着收到了 M4. 显然，接收方不能确认 M4，因为 M3 是收到的失序报文段（按照顺序的 M3 还没有收到）。

快重传算法规定，接收方应及时发送对 M2 的重复确认，这样做可以让发送方及早知道报文段 M3 没有到达接收方。因此，接下来发送方发送 M5 和 M6 后，接收方收到后，也还是要再次发出对 M2 的重复确认。

快重传算法规定，发送方只要一连 l 收到三个重复确认就应当立即重传对方尚未收到的报文段 M3，而不必继续等待为 M3 设置的重传计时器到期。

#### TCP 滑动窗口

TCP 必须要解决的可靠性传输以及包乱序的问题，因此，TCP 必须要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。

所以，TCP 引入了一些技术和设计来做网络流控，Sliding Window（滑动窗口）是其中一个技术。在 TCP 头部信息中讲过有一个字段 Window，又叫 Advertised-Window，这个字段就是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。首先看一下 TCP 缓冲区的一些数据结构：

![tcp缓冲区数据结构](/计算机网络/img/tcp缓冲区数据结构.png)

由图中可以看到：

- 接收端 LastByteRead 指向 TCP 缓冲区中读到的位置，NextByteExpected 指向的地方是连续包的最后一个位置，LastByteRcvd 指向的是接收到的包的最后一个位置；可以看到中间有些数据还没有到达。所以有数据空白区。
- 发送端 LastByteAcked 指向被接收端 Ack 过的位置（表示发送成功确认），LastByteSend 表示发出去了，但还没有收到成功确认的 Ack，LastByteWriter 指向的是上层应用正在写的地方。

于是，接收端在给发送端回 Ack 中会汇报自己的 AdvertisedWindow = MaxRcvBuffer - LastByteRecv - 1；而发送端会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。

下面是一张滑动窗口示意图：

![滑动窗口示意图](/计算机网络/img/滑动窗口示意图.png)

在发送缓存区中，可以将所有数据分为四部分：

- 第一类：已发送且已收到确认。这部分数据是已经发送到接收端，并且接收端也返回了 Ack 确认。这些数据已经完成发送使命，位于滑动窗口之外。
- 第二类：已发送但未收到确认。这部分数据是已经发送到接收端，但是并未收到接收端的 Ack 确认信息。这些数据被认为没有完成发送，数据滑动窗口之内。
- 第三类：未发送但是接收方已经准备好接收。这部分数据并未发送，但是之前的 TCP 数据报中的 Window 字段显示接收方还可以接收这么多的数据到接收方缓存中。这部分数据正在等待发送。属于滑动窗口之内。
- 第四类：未发送且接收方未准备好接收。这部分数据并未发送，并且接收端也不允许发送，因为这些数据已经超出了接收端所接收的范围。属于滑动窗口之外。

发送窗口就是图中的黑色框部分，其大小有两个因素决定：1、接收方提供的窗口大小（TCP 报文段首部中的 window 字段），发送方在三次握手阶段首次得到这个值，之后的通信过程中接收方会根据自己的可用缓存对这个值进行动态调整；2、发送方会根据网络情况维护一个拥塞变量窗口。发送窗口的大小取决于这两个值的最小值。对于发送方来说，发送窗口分为两部分：已经发送的部分（未收到 Ack 确认）和可用的窗口，接收端允许发送但是没有发送的那部分称为可用窗口。

接收窗口类似于发送端，接收端的数据有 3 类，因为接受端并不需要等待 Ack，所以并没有类似接收并确认的分类：

- Received and ACK Not Send to Process：这部分数据属于接收了，也回复了 Ack，但是还没有被上层应用程序所读取。
- Received Not Ack：已经接收，但是还没有回复 Ack
- Not Received：有空位，还没有被接收的数据。

下面是滑动后的示意图（收到 36 的 Ack，并发出了 46-51 的字节）：

![滑动窗口滑动示意图](/计算机网络/img/滑动窗口滑动示意图.png)

>累积确认概念：TCP 并不是每一个报文段都会回复一个 ACK，可能会对两个报文段发送一个 ACK，也可能会对多个报文段发送 1 个 ACK，这称为累积确认。比如说发送方有 1/2/3 3 个报文段，先发送了 2，3 两个报文段，但是接收方期望收到 1 报文段，这个时候 2/3 报文段就只能放在缓存中等待报文 1 的空洞被填上，如果报文 1 一直不来，报文 2/3 也将被丢弃，如果报文 1 来了，那么会发送一个 ACK 对第三个报文段进行确认，就代表对这三个报文段全部进行了确认。

下面是完整的发送端与接收端数据传输的图示：

![tcp 数据传输模型](/计算机网络/img/tcpswflow.png)

**zero wondow**

上图中可以看到 window 是可以变为 0 的，那么如果 Window 变为 0 了，TCP 会怎样？发送端肯定是不能发送数据了，那假如接收方一会 window size 可用了，怎么通知发送端呢？

解决这个问题，TCP 使用了 zero window probe 技术，缩写为 ZWP，也就是说发送端在窗口变成 0 后，会发 ZWP 的包给接收方，让接收方来 Ack 它的 window 尺寸，一般这个值会设置成 3 次，每次大约 30-60 秒。如果 3 次过后还是 0 的话，有的 TCP 实现就会发 RST 把链接断了。

>注意：有等待的地方都可能出现 DDOS 攻击，Zero Window 也不例外，一些攻击者会在和 HTTP 建好链发完 GET 请求后就把 Window 设置为 0，然后服务端就只能等待进行 ZWP，于是攻击者会并发大量这样的请求，把服务端资源耗尽。

**Silly Window Syndrome**

Silly Window Syndrome 翻译成中文就是“糊涂窗口综合症”。如上图所示，如果接收方非常忙，来不及取走 Receive Window 里的数据，就会导致发送方越来越小。到最后，接收方经常是给出几个字节的 window 让发送方发送，而发送方会义无反顾的发送这个几个字节。

一般来说，TCP+IP 头有 40 个字节，为了这个几个字节的数据而加上这么大的开销，这太不经济了。而且对于 TCP 报文段来说，可以传输的最大字节数（Max Segment Size）为 536，如果你每次传输的数据可能塞满 MSS，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽。相当于飞机满载，带宽最高；而飞机只运一个人，那么相当于成本增加了。

要解决这个问题也不难，就是避免对小的 window size 做出响应，直到有足够大的 window size 再响应，这个思路可以同时实现在 sender 和 receiver 两端。

- 如果这个问题是由 Receiver 端引起的，那么就会使用 David D Clark’s 方案。在 receiver 端，如果收到的数据导致 window size 小于某个值，可以直接 ack(0) 回 sender，这样就把 window 给关闭了，也阻止了 sender 再发数据过来，等到 receiver 端处理了一些数据后 windows size 大于等于了 MSS，或者，receiver buffer 有一半为空，就可以把 window 打开让 send 发送数据过来。
- 如果这个问题是由 Sender 端引起的，那么就会使用著名的 Nagle’s algorithm。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size>=MSS 或是 Data Size >=MSS，2）收到之前发送数据的 ack 回包，他才会发数据，否则就是在攒数据。

#### TCP 拥塞控制

TCP 通过 Sliding Window（滑动窗口）来做流量控制（Flow Control），但是这还不够，因为 SlidingWindow 需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP 的设计者觉得，一个伟大而牛逼的协议仅仅做到流控还不够，因为流控只是网络模型 4 层以上的事，TCP 还应该更聪明地知道整个网络上的事。

如果网络上的延时突然增加，那么 TCP 对这个事做出的应对只有重传数据。但是重传会导致网络的负担更重，于是会导致更大的延迟以及丢更多的包，于是这个情况就会进入恶行循环被不断地放大。试想如果一个网络内有成千上万地 TCP 连接都这么行事，那么马上就会形成“网络风暴”，TCP 这个协议就会拖垮整个网络。

因此 TCP 不能忽略网络上发生的事，而无脑地一个劲的重发数据，对网络造成更大的伤害。对此 TCP 的设计理念是：TCP 不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。

>当数据从一个大的管道（比如一个快速局域网）向一个较小的管道（比如较慢的局域网）发送的时候就会发生拥塞，还有一种情况就是当多个输入流到达一个路由器，而路由器的输出流小于这些输入流的总和时，也会发生阻塞。

拥塞控制主要是四个算法：慢启动（slow-start）、拥塞避免（congestion avoidance）、快速重传（fast retransmit）、快速恢复（fast recovery）。

首先介绍一下拥塞窗口（congestion window，简写为 cwnd）的概念：拥塞窗口是由发送方根据网络状况维护的一个变量，用于控制自己发送的数据发送速率。滑动窗口中提到的发送方发送窗口受两个变量约束，一个是接收方告知的窗口大小值，另一个就是发送方自身的拥塞窗口，实际的发送窗口两者取最小值。

##### 慢启动

慢启动并不是指拥塞窗口的增长速度慢（增长速度是指数增长，非常快），而是指 TCP 开始发送时，cwnd 的值设置为 1. 思想就是不要一开始就发送大量的数据，先探测网络的拥塞程度。慢启动的算法如下：

- 连接建好时初始化 cwnd=1，表明可以传一个 MSS（Max Segment Size，tcp 报文段大小的最大值）大小的数据。
- 每当过了一个 RTT（Round Trip Time，数据包从发出去到回来的时间），cwnd=cwnd*2；呈指数上升。
- 还有一个 ssthresh(slow start threshold size，慢启动门限），是一个上限。不可能无穷无尽的以指数级别增加下去，当 cwnd >= ssthresh 时，就会进入“拥塞避免算法”。

所以，如果网速很快的话，ACK 也返回的很快，RTT 也会很短。那么这个慢启动一点也不慢。

![慢启动过程](/计算机网络/img/慢启动过程.png)

##### 拥塞避免

当拥塞窗口大小达到初始 ssthresh 值时，转而采用拥塞避免算法。拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，是网络不容易出现拥塞。思路是：让拥塞窗口 cwnd 缓慢增大，即没经过一个往返时间 RTT 就把发送方的拥塞窗口加 1.

有时候发送方未收到某个报文段的确认，就认为是出现了拥塞。

在早期 TCP Tahoe 版本中，如果发生了超时重传，就判断网络可能出现了拥塞，那么：

- 将 ssthresh 的值更新未发生拥塞时 cwnd 时的一半
- 将 cwnd 值减少为 1，并重新开始执行慢启动算法

![早期慢启动、拥塞避免模型](/计算机网络/img/早期慢启动、拥塞避免模型.png)

##### 快速重传

有时候发送方未收到某个报文段的确认也并非一定是出现了网络堵塞，也可能是其他原因，所以直接执行慢启动算法会影响整体效率，后来的 TCP Reno 版本解决了这一问题，采用快速重传和快速恢复算法。

快速重传要求接收方在收到一个失序的报文段后就立即发出重复确认（使发送方及早知道有报文段没有到达对方），而不要等自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到报文段，而不必必须等待设置的重传计时器时间到期。由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量。

##### 快速恢复

在 TCP Reno 版本中，如果接收方收到了失序的报文段，那么快重传算法要求立即发出重复确认。当发送方连续收到三个重复确认时，就执行“乘法减小”算法：

- 把 ssthresh 阈值更新为未发生拥塞时 cwnd 时的一半
- 并不是执行慢启动算法，考虑到如果网络出现拥塞就不会收到好几个重复确认，因此发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免算法。

![tcp reno 拥塞控制](/计算机网络/img/tcp_reno拥塞控制.png)

## UDP

UDP (UserDatagramProtocol)

## 参考

- [面试准备 TCP 知识，看这一篇就够了](https://segmentfault.com/a/1190000022144695)
- [TCP 的那些事儿（下）](https://coolshell.cn/articles/11609.html)
- Linux 高性能服务器编程
- [5000 字“肝”了这篇 IP 协议](https://mp.weixin.qq.com/s?__biz=MzIxNTg1NzQwMQ==&mid=2247485204&idx=1&sn=f451dae4f4ada4b6ec2f55075df72c27&chksm=9790a682a0e72f9497c13001c215883298c9e7137d160c58c5e417939962e1abb96c0972be17&scene=21#wechat_redirect)