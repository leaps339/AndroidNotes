# TCP、UDP、IP

在[网络分层](/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82.md)中，传输层有两个人尽皆知的协议--TCP与UDP。

TCP协议（Transmission Control Protocol，传输控制协议）为应用层提供可靠的、面向连接的和基于流（stream）的服务。TCP协议使用超时重传、数据确认等方式确保数据包被正确地发送至目的端，因此TCP服务是可靠的。使用TCP协议通信的双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。当通信结束时，双方必须关闭连接以释放这些内核数据。TCP服务是基于流的。**基于流的数据没有边界（长度）限制，它源源不断地从通信的一段流入另一端。** 发送端可以逐个字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。

UDP协议（User Datagram Protocol，用户数据报协议）则与TCP协议完全相反，它为应用层提供不可靠、无连接的和基于数据报的服务。“不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则UDP协议只是简单地通知应用程序发送失败。因此，使用UDP协议地应用程序通常要自己处理数据确认、超时重传等逻辑。UDP协议是无连接地，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息）。**基于数据报的服务，是相对基于流服务而言的。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。**

## TCP

TCP是TCP/IP协议族中的一个重要协议，可以从

- TCP头部信息：TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口号、目的端口号、管理TCP连接，控制两个方向的数据流。
- TCP状态转移过程。TCP连接的任意一端都是一个状态机。在TCP连接从建立到断开的整个过程中，连接两端的状态机将经历不同的状态变迁。
- TCP数据流：通过分析TCP数据流，可以从网络应用程序外部来了解应用层协议和通信双方交换的应用程序数据。
- TCP数据流的控制：为了保证可靠传输和提高网络通信的质量，内核需要对TCP数据流进行控制。

四个方面去了解TCP。

### TCP头部信息

详见[Socket通信原理](/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.md)中的**TCP报文段首部章节。**

### TCP状态转移过程

详见[Socket通信原理](/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.md)中的**TCP的状态机、TCP的三次握手和四次挥手 章节。**

### TCP数据流

基于流的数据没有边界（长度）限制，它源源不断地从通信的一段流入另一端。发送端可以逐个字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。

TCP字节流与UDP数据报的区别，如果对应到实际编程中，则体现为通信双方是否必须执行相同次数的读、写操作。当发送端应用连续多次执行多次写操作时，TCP模块先将这些数据放入到TCP发送缓冲区中。当TCP模块真正开始发送数据时，发送缓冲区中等待发送的数据可能被封装成一个或多个TCP报文段发出。因此，TCP模块发出的TCP报文段个数和应用程序执行写操作次数之间没有固定数量关系。

同样的，当接收端收到一个或多个TCP报文段后，将按照TCP报文段的序号依次放入到TCP接收缓冲区中，并通知应用程序读取数据。接收端应用程序可以一次性将TCP接收缓冲区的数据全部取出，也可以分多次读取，这取决于用户指定的应用程寻读缓冲区的大小。因此，TCP模块接收到的TCP报文段个数和应用程序执行的读操作次数也没有固定的数量关系。

这就是字节流：应用程序对数据的发送和接收是没有边界的。

![tcp字节流服务](/计算机网络/img/tcp字节流服务.png)

与之不同的是UDP，一种基于数据报的协议。发送端应用程序每执行一次写操作，UDP模块就将其封装称一个UDP数据报并发送之。接收端必须及时针对每一个UDP数据执行读操作，否则就会丢包。并且，如果用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将被截断。

![udp数据报服务](/计算机网络/img/udp数据报服务.png)

### TCP数据流的控制

TCP的三大特性--可靠、面向连接、基于流。其可靠性的保证，除了建立稳定的连接，在数据的收发处理上，也有一些措施去保证。

- 合理的数据大小：TCP 发送的数据并不是固定的大小，而是会根据实际情况调整报文段的大小。
- 检验和：发送端按照特定算法（CRC，参考TCP头部信息）计算出 TCP 报文段的检验和并存储在 TCP 首部中的对应字段上，接收端在接收时会以同样的方式计算校验和，如果不一致，说明报文段出现错误，会将其丢弃。
- 序号与确认序号：对乱序的数据进行排序后发给应用层，并丢弃重复的数据。
- 超时重传机制：当 TCP 发出一个报文段后，它会启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段，后面会细讲这个机制。
- 连接管理：也就是三次握手和四次挥手，连接的可靠性是整体可靠性的前提。
- 流量控制：TCP 双方都有固定大小的缓冲区，流量控制的原理是利用滑动窗口控制数据发送速度，避免缓冲区溢出导致数据丢失。
- 拥塞控制：TCP 利用慢启动和拥塞避免等算法实现了拥塞控制。

#### TCP重传机制

TCP要保证所有的包都可以到达，必须要有确认重传机制。

接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1，2，3，4，5一共5份数据，接收端收到了1，2，于是回ack 3，然后收到了4（此时3没收到），此时TCP会怎么办？因为SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包。

**超时重传机制**

一种是不会ack，死等3，当发送方发现收不到3地ack超时后，会重传3.一旦接收方收到3后，会ack回4--代表3和4都收到了。

但是，这种方法有着比较严重地问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到ack，所以发送方可能会悲观地认为也丢了，所以有可能导致4和5的重传。

对此有两种选择：一种是仅重传timeout的包。也就是第三份数据。
另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。

这两种方法总体来说都不好。因为都在等timeout，timeout可能会很长。

**快速重传机制（快重传 Fast Retransmit）**

另一种做法是，**不以时间驱动，而已数据驱动重传。**快重传算法要求接收方每收到一个失序的报文段后就立即发出重复确认（使发送方及早知道有报文段没有到达对方）而不要等待自己发送数据时才进行捎带确认。

快重传示意图如下：

![快重传示意图](/计算机网络/img/快重传示意图.webp)

接收方收到了M1和M2后都分别发出了确认。假如接收方没有收到M3但接着收到了M4.显然，接收方不能确认M4，因为M3是收到的失序报文段（按照顺序的M3还没有收到）。

快重传算法规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。因此，接下来发送方发送M5和M6后，接收方收到后，也还是要再次发出对M2的重复确认。

快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待为M3设置的重传计时器到期。