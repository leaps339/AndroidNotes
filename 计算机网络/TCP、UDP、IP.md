# TCP、UDP、IP

在[网络分层](/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82.md)中，传输层有两个人尽皆知的协议--TCP与UDP。

TCP协议（Transmission Control Protocol，传输控制协议）为应用层提供可靠的、面向连接的和基于流（stream）的服务。TCP协议使用超时重传、数据确认等方式确保数据包被正确地发送至目的端，因此TCP服务是可靠的。使用TCP协议通信的双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。当通信结束时，双方必须关闭连接以释放这些内核数据。TCP服务是基于流的。**基于流的数据没有边界（长度）限制，它源源不断地从通信的一段流入另一端。** 发送端可以逐个字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。

UDP协议（User Datagram Protocol，用户数据报协议）则与TCP协议完全相反，它为应用层提供不可靠、无连接的和基于数据报的服务。“不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则UDP协议只是简单地通知应用程序发送失败。因此，使用UDP协议地应用程序通常要自己处理数据确认、超时重传等逻辑。UDP协议是无连接地，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息）。**基于数据报的服务，是相对基于流服务而言的。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。**

## TCP

TCP是TCP/IP协议族中的一个重要协议，可以从

- TCP头部信息：TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口号、目的端口号、管理TCP连接，控制两个方向的数据流。
- TCP状态转移过程。TCP连接的任意一端都是一个状态机。在TCP连接从建立到断开的整个过程中，连接两端的状态机将经历不同的状态变迁。
- TCP数据流：通过分析TCP数据流，可以从网络应用程序外部来了解应用层协议和通信双方交换的应用程序数据。
- TCP数据流的控制：为了保证可靠传输和提高网络通信的质量，内核需要对TCP数据流进行控制。

四个方面去了解TCP。

### TCP头部信息

详见[Socket通信原理](/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.md)中的**TCP报文段首部章节。**

### TCP状态转移过程

详见[Socket通信原理](/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Socket%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.md)中的**TCP的状态机、TCP的三次握手和四次挥手 章节。**

### TCP数据流

基于流的数据没有边界（长度）限制，它源源不断地从通信的一段流入另一端。发送端可以逐个字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。

TCP字节流与UDP数据报的区别，如果对应到实际编程中，则体现为通信双方是否必须执行相同次数的读、写操作。当发送端应用连续多次执行多次写操作时，TCP模块先将这些数据放入到TCP发送缓冲区中。当TCP模块真正开始发送数据时，发送缓冲区中等待发送的数据可能被封装成一个或多个TCP报文段发出。因此，TCP模块发出的TCP报文段个数和应用程序执行写操作次数之间没有固定数量关系。

同样的，当接收端收到一个或多个TCP报文段后，将按照TCP报文段的序号依次放入到TCP接收缓冲区中，并通知应用程序读取数据。接收端应用程序可以一次性将TCP接收缓冲区的数据全部取出，也可以分多次读取，这取决于用户指定的应用程寻读缓冲区的大小。因此，TCP模块接收到的TCP报文段个数和应用程序执行的读操作次数也没有固定的数量关系。

这就是字节流：应用程序对数据的发送和接收是没有边界的。

![tcp字节流服务](/计算机网络/img/tcp字节流服务.png)

与之不同的是UDP，一种基于数据报的协议。发送端应用程序每执行一次写操作，UDP模块就将其封装称一个UDP数据报并发送之。接收端必须及时针对每一个UDP数据执行读操作，否则就会丢包。并且，如果用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将被截断。

![udp数据报服务](/计算机网络/img/udp数据报服务.png)

### TCP数据流的控制

TCP的三大特性--可靠、面向连接、基于流。其可靠性的保证，除了建立稳定的连接，在数据的收发处理上，也有一些措施去保证。

- 合理的数据大小：TCP 发送的数据并不是固定的大小，而是会根据实际情况调整报文段的大小。
- 检验和：发送端按照特定算法（CRC，参考TCP头部信息）计算出 TCP 报文段的检验和并存储在 TCP 首部中的对应字段上，接收端在接收时会以同样的方式计算校验和，如果不一致，说明报文段出现错误，会将其丢弃。
- 序号与确认序号：对乱序的数据进行排序后发给应用层，并丢弃重复的数据。
- 超时重传机制：当 TCP 发出一个报文段后，它会启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段，后面会细讲这个机制。
- 连接管理：也就是三次握手和四次挥手，连接的可靠性是整体可靠性的前提。
- 流量控制：TCP 双方都有固定大小的缓冲区，流量控制的原理是利用滑动窗口控制数据发送速度，避免缓冲区溢出导致数据丢失。
- 拥塞控制：TCP 利用慢启动和拥塞避免等算法实现了拥塞控制。

#### TCP重传机制

TCP要保证所有的包都可以到达，必须要有确认重传机制。

接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1，2，3，4，5一共5份数据，接收端收到了1，2，于是回ack 3，然后收到了4（此时3没收到），此时TCP会怎么办？因为SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包。

**超时重传机制**

一种是不会ack，死等3，当发送方发现收不到3地ack超时后，会重传3.一旦接收方收到3后，会ack回4--代表3和4都收到了。

但是，这种方法有着比较严重地问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到ack，所以发送方可能会悲观地认为也丢了，所以有可能导致4和5的重传。

对此有两种选择：一种是仅重传timeout的包。也就是第三份数据。
另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。

这两种方法总体来说都不好。因为都在等timeout，timeout可能会很长。

**快速重传机制（快重传 Fast Retransmit）**

另一种做法是，**不以时间驱动，而已数据驱动重传。**快重传算法要求接收方每收到一个失序的报文段后就立即发出重复确认（使发送方及早知道有报文段没有到达对方）而不要等待自己发送数据时才进行捎带确认。

快重传示意图如下：

![快重传示意图](/计算机网络/img/快重传示意图.webp)

接收方收到了M1和M2后都分别发出了确认。假如接收方没有收到M3但接着收到了M4.显然，接收方不能确认M4，因为M3是收到的失序报文段（按照顺序的M3还没有收到）。

快重传算法规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。因此，接下来发送方发送M5和M6后，接收方收到后，也还是要再次发出对M2的重复确认。

快重传算法规定，发送方只要一连l收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待为M3设置的重传计时器到期。

#### TCP滑动窗口

TCP必须要解决的可靠性传输以及包乱序的问题，因此，TCP必须要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。

所以，TCP引入了一些技术和设计来做网络流控，Sliding Window（滑动窗口）是其中一个技术。在TCP头部信息中讲过有一个字段Window，又叫Advertised-Window，这个字段就是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。首先看一下TCP缓冲区的一些数据结构：

![tcp缓冲区数据结构](/计算机网络/img/tcp缓冲区数据结构.png)

由图中可以看到：

- 接收端LastByteRead指向TCP缓冲区中读到的位置，NextByteExpected指向的地方是连续包的最后一个位置，LastByteRcvd指向的是接收到的包的最后一个位置；可以看到中间有些数据还没有到达。所以有数据空白区。
- 发送端LastByteAcked指向被接收端Ack过的位置（表示发送成功确认），LastByteSend表示发出去了，但还没有收到成功确认的Ack，LastByteWriter指向的是上层应用正在写的地方。

于是，接收端在给发送端回Ack中会汇报自己的AdvertisedWindow = MaxRcvBuffer - LastByteRecv - 1；而发送端会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。

下面是一张滑动窗口示意图：

![滑动窗口示意图](/计算机网络/img/滑动窗口示意图.png)

在发送缓存区中，可以将所有数据分为四部分：

- 第一类：已发送且已收到确认。这部分数据是已经发送到接收端，并且接收端也返回了Ack确认。这些数据已经完成发送使命，位于滑动窗口之外。
- 第二类：已发送但未收到确认。这部分数据是已经发送到接收端，但是并未收到接收端的Ack确认信息。这些数据被认为没有完成发送，数据滑动窗口之内。
- 第三类：未发送但是接收方已经准备好接收。这部分数据并未发送，但是之前的TCP数据报中的Window字段显示接收方还可以接收这么多的数据到接收方缓存中。这部分数据正在等待发送。属于滑动窗口之内。
- 第四类：未发送且接收方未准备好接收。这部分数据并未发送，并且接收端也不允许发送，因为这些数据已经超出了接收端所接收的范围。属于滑动窗口之外。

发送窗口就是图中的黑色框部分，其大小有两个因素决定：1、接收方提供的窗口大小（TCP报文段首部中的window字段），发送方在三次握手阶段首次得到这个值，之后的通信过程中接收方会根据自己的可用缓存对这个值进行动态调整；2、发送方会根据网络情况维护一个拥塞变量窗口。发送窗口的大小取决于这两个值的最小值。对于发送方来说，发送窗口分为两部分：已经发送的部分（未收到Ack确认）和可用的窗口，接收端允许发送但是没有发送的那部分称为可用窗口。

接收窗口类似于发送端，接收端的数据有3类，因为接受端并不需要等待Ack，所以并没有类似接收并确认的分类：

- Received and ACK Not Send to Process：这部分数据属于接收了，也回复了Ack，但是还没有被上层应用程序所读取。
- Received Not Ack：已经接收，但是还没有回复Ack
- Not Received：有空位，还没有被接收的数据。

下面是滑动后的示意图（收到36的Ack，并发出了46-51的字节）：

![滑动窗口滑动示意图](/计算机网络/img/滑动窗口滑动示意图.png)

>累积确认概念：TCP并不是每一个报文段都会回复一个ACK，可能会对两个报文段发送一个ACK，也可能会对多个报文段发送1个ACK，这称为累积确认。比如说发送方有1/2/3 3个报文段，先发送了2，3两个报文段，但是接收方期望收到1报文段，这个时候2/3报文段就只能放在缓存中等待报文1的空洞被填上，如果报文1一直不来，报文2/3也将被丢弃，如果报文1来了，那么会发送一个ACK对第三个报文段进行确认，就代表对这三个报文段全部进行了确认。

下面是完整的发送端与接收端数据传输的图示：

![tcp数据传输模型](/计算机网络/img/tcpswflow.png)

**zero wondow**

上图中可以看到window是可以变为0的，那么如果Window变为0了，TCP会怎样？发送端肯定是不能发送数据了，那假如接收方一会window size可用了，怎么通知发送端呢？

解决这个问题，TCP使用了zero window probe技术，缩写为ZWP，也就是说发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来Ack它的window尺寸，一般这个值会设置成3次，每次大约30-60秒。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。

>注意：有等待的地方都可能出现DDOS攻击，Zero Window也不例外，一些攻击者会在和HTTP建好链发完GET请求后就把Window设置为0，然后服务端就只能等待进行ZWP，于是攻击者会并发大量这样的请求，把服务端资源耗尽。

**Silly Window Syndrome**

Silly Window Syndrome翻译成中文就是“糊涂窗口综合症”。如上图所示，如果接收方非常忙，来不及取走Receive Window里的数据，就会导致发送方越来越小。到最后，接收方经常是给出几个字节的window让发送方发送，而发送方会义无反顾的发送这个几个字节。

一般来说，TCP+IP头有40个字节，为了这个几个字节的数据而加上这么大的开销，这太不经济了。而且对于TCP报文段来说，可以传输的最大字节数（Max Segment Size）为536，如果你每次传输的数据可能塞满MSS，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽。相当于飞机满载，带宽最高；而飞机只运一个人，那么相当于成本增加了。

要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。

- 如果这个问题是由Receiver端引起的，那么就会使用 David D Clark’s 方案。在receiver端，如果收到的数据导致window size小于某个值，可以直接ack(0)回sender，这样就把window给关闭了，也阻止了sender再发数据过来，等到receiver端处理了一些数据后windows size 大于等于了MSS，或者，receiver buffer有一半为空，就可以把window打开让send 发送数据过来。
- 如果这个问题是由Sender端引起的，那么就会使用著名的 Nagle’s algorithm。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size>=MSS 或是 Data Size >=MSS，2）收到之前发送数据的ack回包，他才会发数据，否则就是在攒数据。

#### TCP拥塞控制

TCP通过Sliding Window（滑动窗口）来做流量控制（Flow Control），但是这还不够，因为SlidingWindow需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流控还不够，因为流控只是网络模型4层以上的事，TCP还应该更聪明地知道整个网络上的事。

如果网络上的延时突然增加，那么TCP对这个事做出的应对只有重传数据。但是重传会导致网络的负担更重，于是会导致更大的延迟以及丢更多的包，于是这个情况就会进入恶行循环被不断地放大。试想如果一个网络内有成千上万地TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。

因此TCP不能忽略网络上发生的事，而无脑地一个劲的重发数据，对网络造成更大的伤害。对此TCP的设计理念是：TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。

拥塞控制主要是四个算法：慢启动（slow-start）、拥塞避免（congestion avoidance）、快速重传（fast retransmit）、快速恢复（fast recovery）。

## 参考

- [面试准备 TCP 知识，看这一篇就够了](https://segmentfault.com/a/1190000022144695)
- [TCP 的那些事儿（下）](https://coolshell.cn/articles/11609.html)